ch08
==========
# 08. 동적 계획법
## 8.01 도입.
### 중복되는 부분 문제
- [wiki:Dynamic_programming]
 - In mathematics, computer science, and economics, dynamic programming is a method for solving complex problems by breaking them down into simpler subproblems. It is applicable to problems exhibiting the properties of [wiki:Overapping_subproblem] and [wiki:Optimal_substructure] (described below). When applicable, the method takes far less time than naive methods.

- [wiki:Overapping_subproblem]
 - In computer science, a problem is said to have overlapping subproblems if the problem can be broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblem.
 - 동일한 방식을 여러번 적용해서 풀어낼 수 있는 문제들로 구성된 문제. (subproblem들이 중복)

- [wiki:Optimal_substructure]
 - In computer science, a problem is said to have optimal substructure if an optimal solution can be constructed efficiently from optimal solutions of its subproblems. **This property is used to determine the usefulness of dynamic programming and greedy algorithms for a problem.**
 - 하위 문제의 최적의 해로, 상위 문제의 최적의 해가 결정되는 구조.

- `동적 계획법(dynamic programming)`
 - 수학, 컴퓨터공학, 경제학에서, 동적계획법은 복잡한 문제를 단순한 하위문제로 나누어 풀어가는 방법을 예기한다.

- ex) `동적 계획법`과 `저희 스터디`
 - 혼자서 다 보기 힘드니, 챕터별로 사람을 나누어서, 스터디를 해나간다.
 - 스터디한 내용을 기록으로 남기어, 훗날 스터디 참여했던 인원 뿐만 아니라, 다른 이들도 스터디 진행 내역을 빨리 알아 낼 수 있다.

- 장점과 문제점은?
 - 장점 : 미리 저장해 놨다가 써먹으니 중복계산이 불필요.
 - 문제점 : 정보를 저장해야 하는데 무얼 저장해야할지 정하는것. 저장해 놓은걸 해제할 시기를 정하는것.

--------------------------------------------------------------------------------

- 이항갯수 (binomial coefficient)
 - n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수.

;; 수학공식이용.
```clojure
;; 수학공식이용
;; 단, n!이나 r!은 계산량이 많음.
(defn factorial [n]
  (reduce * (range 1 (inc n))))

(defn bino-math
  [n r]
  (/ (factorial n)
     (* (factorial r) (factorial (- n r)))))
;; (bino-math 4 2) ; => 6
```

;; 코드8.1 재귀 호출을 이용한 이항 계수의 계산. 209p
```clojure
;; 코드8.1 재귀 호출을 이용한 이항 계수의 계산. 209p

(defn bino
  "nCr을 반환한다"
  [n r]
  (if (or (zero? r) (= n r))
    1
    (+ (bino (- n 1) (- r 1)) (bino (- n 1) r))))

;; (bino 4 2) ; => 6
```

;; 코드8.2 메모이제이션을 이용한 이항 계수의 계산. 211p
```clojure
;; 코드8.2 메모이제이션을 이용한 이항 계수의 계산. 211p
(defn string-nCr
  [n r]
  (str n "C" r))

(def ^:dynamic *cache* (atom {}))

(defn bino2
  [n r]
  (if (or (zero? r) (= n r))
    1
    ;; n, r로부터 string "nCr"을 얻어오고,
    (let [cache-key (string-nCr n r)]

      (if-let [cached-nCr (find @*cache* cache-key)]
        ;; cache["nCr"]이 있으면, cache["nCr"]을 반환하고,
        (val cached-nCr)

        ;; 아니면, nCr(n, r)을 계산해서, cache["nCr"] = nCr(n, r)을 넣고 반환한다.
        (let [nCr (+ (bino2 (- n 1) (- r 1)) (bino2 (- n 1) r))]
          (swap! *cache* assoc cache-key nCr)
          nCr)))))

;; (bino2 4 2) ; => 6
;; *cache* ; => #<Atom@67ae2ffe: {"4C2" 6, "3C2" 3, "3C1" 3, "2C1" 2}>

```

--------------------------------------------------------------------------------

### 메모이제이션을 적용할 수 있는 경우
* `memization`은 `referentail transparent`가 가능한 경우에 적용가능.
 - `memoization`: 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재사용하는 최적화 기법.
 - `cache`: 이미 계산한 값을 저장해 두는 메모리 장소.
 - `referentail transparent`: 함수의 반환 값이 입력 값만으로 결정되는것.

* 프로그래밍에서 주의점.
 - 전역변수.
 - 클래스 변수.
 - 입력객체(파일 등등)
 - 등등..

--------------------------------------------------------------------------------

### 메모이제이션 구현 패턴
- 딱히 별로 중요하지 않은듯.
 * 기저 사례 처리
 * cache의 초기값 설정
 * 배열일경우, ref이용.
 * memset을 이용 cache[]초기화

--------------------------------------------------------------------------------

#### clojure에서는??

clojure.core/memoize의 소스.

```clojure
(defn memoize
  "Returns a memoized version of a referentially transparent function. The
  memoized version of the function keeps a cache of the mapping from arguments
  to results and, when calls with the same arguments are repeated often, has
  higher performance at the expense of higher memory use."
  {:added "1.0"
   :static true}
  [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
```

atom dic에 args를 키로해서 캐슁하는것...

먼가 이상하다.

검색중 [projecteuler]를 근성으로 풀어가고 있는 [용자][blog:clojure-memoize]발견.

문제점을 확인할 수 있었음.

```clojure
;; ref: http://ypsilonbox.blogspot.kr/2011/06/clojure-memoize.html
(defn fib [n]
  (do
    (println "->"n)
    (if (<= n 1)
      n
      (+ (fib (dec n)) (fib (- n 2))))))

(def mem-fib (memoize fib)) ;; 예전에 문제됐던것.
(mem-fib 4)
(mem-fib 3)
(mem-fib 5)

(def fib (memoize fib)) ;; 현 1.5에선 문제없네?
(fib 4)
(fib 3)
(fib 5)
```

```clojure
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; create memoised func

(defmacro defn-memo
  "Creates memoised function, and accessor of the memo which named -data,
   memo deletion function named -clear"
  [name arg-list & body]
  `(let [mem# (atom {})]

     (defn ~(symbol (str (str name) "-data")) []
       @mem#)

     (defn ~(symbol (str (str name) "-clear")) []
       (reset! mem# {}))

     (defn ~name ~arg-list
       (if-let [e# (find @mem# ~arg-list)]
          (val e#)
          (let [ret# ~@body]
              (swap! mem# assoc ~arg-list ret#)
              ret#)))))
;;

(defn-memo mem-fib [n]
  (do
     (println "-->" n)
     (if (<= n 1)
        n
        (+ (mem-fib (dec n)) (mem-fib (- n 2))))))

(mem-fib 4)
(mem-fib 3)
(mem-fib 5)
(mem-fib-data)
(mem-fib-clear)
(mem-fib-data)
```

물론 단순히 args에 의해 결정되는 memoize도 필요하나. clojure.core/memoize는 cache관리가 어렵다.

누가 해논건 없나? => [github:core.memoize]
cache 정책 및 조작할 수 있는 api제공.

--------------------------------------------------------------------------------

### 메모이제이션의 시간 복잡도 분석
* (존재하는 부분 문제의 수) x (한 부분 문제를 풀때 필요한 반복문의 수행 횟수)


```
bibo2를 보자면...

존재하는 부분 문제의 수. 최악의 경우는 다이아몬드를 이룰때임.

      1
     1 1
    1 2 1
   1 3 3 1
  1 4 6 4 1
 1 5 10 10 5 1
1 6 15 20 15 6 1

2C1 =>  4 - 중심이 (1 1)     - 2개
4C2 =>  9 - 중심이 (1 2 1)   - 3개
6C3 => 16 - 중심이 (1 3 3 1) - 4개


nCr의 n을 a라, 중심의 갯수를 n이라 하면
n = a/2 + 1


4C2를 예로들면
      1     - 1 * 2
     1 1    - 2 * 2
    1 2 1   - 3 * 1
     3 3 
      6

계산할 때 만날 수 있는 부분 문제의 수는
sigma(k = 1 ~ n) : (2 * k) - n - 1(이때 1은 자기자신)


2 * (n*(n+1)/2) - n = n^2

이제 n을 a/2+1로 치환하면

O(1/4a^2 + a + 1) = O(1/4a^2) = O(a^2).

캐쉬가 한번도 안된 최악의 경우이지, 됐다하면 수행시간은 더 짧아질것임.
```
--------------------------------------------------------------------------------

### 예제: 외발뛰기 (문제ID:JUMPGAME, 난이도: 하)

* n*n크기의 격자에 1에서 9까지의 정수를 쓴 게임판이 있다.
* 각 칸에 적혀있는 숫자만큼, 오른쪽이나 아래로 움직일 수 있다.
* (0,0)에서 (n-1, n-1)까지 도달하는 방법이 존재하는가?

#### 재귀 호출에서 시작하기

;; 코드8.4 외발 뛰기 문제를 해결하는 재귀 호출 알고리즘.
```clojure
;; 예제: 외발 뛰기 (문제ID:JUMPGAME, 난이도:하)
;; 코드8.4 외발 뛰기 문제를 해결하는 재귀 호출 알고리즘.
;; x: left-to-right
;; y: up-to-down
(defn try-jump
  [n board]

  (defn board-xy
    [x y]
    ;; (nth (nth board y) x)
    (get-in board [y x]))

  (defn jump
    [x y]
    (cond (or (>= x n) (>= y n)) false
          (and (= x (- n 1)) (= y (- n 1))) true
          :else (let [jump-size (board-xy x y)
                      x-jump (jump (+ x jump-size) y)
                      y-jump (jump x (+ y jump-size))]
                  ;; (when (or x-jump y-jump)
                  (println (format "jump %d,%d (%d) : %s-%s" x y (board-xy x y) x-jump y-jump))
                  ;; )
                  (or x-jump y-jump))))
  (jump 0 0))

(def n 7)

(def board
  [[2 5 1 6 1 4 1]
   [6 1 1 2 2 9 3]
   [7 2 3 2 1 3 1]
   [1 1 3 1 7 1 2]
   [4 1 2 3 4 1 2]                      ; 2일때는 정상.
   [3 3 1 2 3 4 1]
   [1 5 2 9 4 7 '*]])

(def wrong-board
  [[2 5 1 6 1 4 1]
   [6 1 1 2 2 9 3]
   [7 2 3 2 1 3 1]
   [1 1 3 1 7 1 2]
   [4 1 2 3 4 1 3]                      ; 3일때는 안됨.
   [3 3 1 2 3 4 1]
   [1 5 2 9 4 7 '*]])

;; (try-jump n board)
;; jump 6,4 (2) : false-true
;; jump 3,4 (3) : true-false
;; jump 3,3 (1) : false-true
;; jump 3,1 (2) : false-true
;; jump 2,1 (1) : true-false
;; jump 2,0 (1) : false-true
;; jump 0,0 (2) : true-false

;; (try-jump n wrong-board) ; => false
```

;; 코드 8.5 외발 뛰기 문제를 해결하는 동적 계획법 알고리즘
```clojure
;; 코드 8.5 외발 뛰기 문제를 해결하는 동적 계획법 알고리즘.

(defn try-jump2
  [n board]

  (defn make-empty-board
    [n]
    (vec (repeat n
                 (vec (repeat n nil)))))

  (def ^:dynamic *cache* (atom (make-empty-board n)))

  (defn get-cached
    [x y]
    (get-in @*cache* [y x]))

  (defn caching
    [x y val]
    (swap! *cache* assoc-in [y x] val))

  (defn board-xy
    [x y]
    (get-in board [y x]))

  (defn jump2
    [x y]
    (cond (or (>= x n) (>= y n)) false
          (and (= x (- n 1)) (= y (- n 1))) true
          :else
          (let [ret (get-cached x y)]
            (if (not (nil? ret))
              ret
              (let [jump-size (board-xy x y)
                    x-jump (jump2 (+ x jump-size) y)
                    y-jump (jump2 x (+ y jump-size))
                    is-jumpable (or x-jump y-jump)]
                (caching x y is-jumpable)
                ;;(when (or x-jump y-jump)
                (println (format "jump %d,%d (%d) : %s-%s" x y (board-xy x y) x-jump y-jump))
                ;;)
                is-jumpable)))))
    (jump2 0 0)
    *cache*)

(def worst-board
  [[1 1 1 1 1 1 1]
   [1 1 1 1 1 1 1]
   [1 1 1 1 1 1 1]
   [1 1 1 1 1 1 1]
   [1 1 1 1 1 1 1]
   [1 1 1 1 1 1 2]
   [1 1 1 1 1 2 '*]])

;; (try-jump n worst-board) ; printed 2500 lines.
;; (try-jump2 n worst-board) ; printed 50 lines.

```

--------------------------------------------------------------------------------

## 8.02 문제: 와일드카드 (문제 ID:WILDCARD, 난이도: 중)
* 와일드카드(`?`, `*`)를 지닌 문자열과 매칭되는 문자열 구하기.
* 와일드카드패턴 : 알파뱃 소문자, 대문자, `?`, `*`, 공백포함하지않음.
 - `?`는 어떠한 글자 하나.
 - `*`는 0글자 이상.
* 매칭될문자열 : 알파뱃 소문자, 대문자, 소문자, 공백포함하지않음.

;; 코드 8.6 와일드 카드 문제를 해결하는 완전 탐색 알고리즘.
```clojure
;; 코드 8.6 와일드 카드 문제를 해결하는 완전 탐색 알고리즘.
(defn wildcard-match
  [w s]
  (let [pos (atom 0)
        w-size (count w)
        s-size (count s)]
    ;; w[pos]와 s[pos]를 찾줘나간다.
    (while (and (< @pos s-size)
                (< @pos w-size)
                (or (= \? (nth w @pos)) (= (nth w @pos) (nth s @pos))))
      (swap! pos inc))

    ;; 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응.
    (cond (= @pos w-size) (= @pos s-size)
          (not= \* (nth w @pos)) false
          :else
          ;; *을 만나서 끝날경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인.
          (loop [skip 0]
            (if (> (+ @pos skip) s-size)
              false
              (if (wildcard-match (subs w (inc @pos)) (subs s (+ @pos skip)))
                true
                (recur (inc skip))))))))

(defn filter-wildcard-matchs
  [wildcard-str samples]
  (filter (fn [s] (wildcard-match wildcard-str s)) samples))


(= (filter-wildcard-matchs "he?p" '("help" "heap" "helpp"))
   '("help" "heap"))

(= (filter-wildcard-matchs "*p*" '("help"  "papa" "hello"))
   '("help" "papa"))

(= (filter-wildcard-matchs "*bb*" '("babbbc"))
   '("babbbc"))
```



## 8.03 풀이: 와일드카드

--------------------------------------------------------------------------------

## 8.04 전통적 최적화 문제들

--------------------------------------------------------------------------------

## 8.05 문제: 합친LIS(문제 ID JLIS, 난이도: 하)
LIS가 뭐지?

## 8.06 풀이: 합친 LIS

--------------------------------------------------------------------------------

## 8.07 문제: 원주율 외우기 (문제ID:PI, 난이도: 하)

## 8.08 풀이: 원주율 외우기

--------------------------------------------------------------------------------

==== 여기까지 1차 목표. =======

## 8.09 문제: Quatization (문제 ID: QUANTIZE, 난이도: 중)
## 8.10 풀이: Quatization
## 8.11 경우의 수와 확률
## 8.12 문제: 비대칭 타일링 (문제 ID: ASYMTILING, 난이도: 하)
## 8.13 풀이: 비대칭 타일링
## 8.14 문제: 폴리오미노 (문제 ID: POLY, 난이도: 중)
## 8.15 풀이: 폴리오미노
## 8.16 문제: 두니발 박사의 탈옥 (문제 ID: NUMB3RS, 난이도: 중)
## 8.17 풀이: 두니발 박사의 탈옥

==== 여기까지 2차 목표. =======

# 느낀점
 - `동적 계획법`이란 단어가 생소해서 선택했는데... 과연..
 - 
 - 


[blog:dynamic programming?]: http://siriuseven.egloos.com/563101
[wiki:Dynamic_programming]: http://en.wikipedia.org/wiki/Dynamic_programming
[wiki:Overapping_subproblem]: http://en.wikipedia.org/wiki/Overlapping_subproblem
[wiki:Optimal_substructure]: http://en.wikipedia.org/wiki/Optimal_substructure
[projecteuler]: http://projecteuler.net/
[blog:clojure-memoize]: http://translate.google.com/translate?sl=ja&tl=ko&js=n&u=http://ypsilonbox.blogspot.kr/2011/06/clojure-memoize.html
[github:core.memoize]: https://github.com/clojure/core.memoize
[ppt:동적 프로그래밍-강원대학교]: cs.kangwon.ac.kr/~ysmoon/courses/2007_1/alg/06.ppt