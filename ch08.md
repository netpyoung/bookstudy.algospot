ch08
==========
# 08. 동적 계획법
## 8.01 도입.
### 중복되는 부분 문제
- [wiki:Dynamic_programming]
 - In mathematics, computer science, and economics, dynamic programming is a method for solving complex problems by breaking them down into simpler subproblems. It is applicable to problems exhibiting the properties of [wiki:Overapping_subproblem] and [wiki:Optimal_substructure] (described below). When applicable, the method takes far less time than naive methods.

- [wiki:Overapping_subproblem]
 - In computer science, a problem is said to have overlapping subproblems if the problem can be broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblem.
 - 동일한 방식을 여러번 적용해서 풀어낼 수 있는 문제들로 구성된 문제. (subproblem들이 중복)

- [wiki:Optimal_substructure]
 - In computer science, a problem is said to have optimal substructure if an optimal solution can be constructed efficiently from optimal solutions of its subproblems. **This property is used to determine the usefulness of dynamic programming and greedy algorithms for a problem.**
 - 하위 문제의 최적의 해로, 상위 문제의 최적의 해가 결정되는 구조.

- `동적 계획법(dynamic programming)`
 - 수학, 컴퓨터공학, 경제학에서, 동적계획법은 복잡한 문제를 단순한 하위문제로 나누어 풀어가는 방법을 예기한다.

- ex) `동적 계획법`과 `저희 스터디`
 - 혼자서 다 보기 힘드니, 챕터별로 사람을 나누어서, 스터디를 해나간다.
 - 스터디한 내용을 기록으로 남기어, 훗날 스터디 참여했던 인원 뿐만 아니라, 다른 이들도 스터디 진행 내역을 빨리 알아 낼 수 있다.

- 장점과 문제점은?
 - 장점 : 미리 저장해 놨다가 써먹으니 중복계산이 불필요.
 - 문제점 : 정보를 저장해야 하는데 무얼 저장해야할지 정하는것. 저장해 놓은걸 해제할 시기를 정하는것.

--------------------------------------------------------------------------------

- 이항갯수 (binomial coefficient)
 - n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수.


#### ;; 수학공식이용.
```clojure
;; 수학공식이용
;; 단, n!이나 r!은 계산량이 많음.
(defn factorial [n]
  (reduce * (range 1 (inc n))))

(defn bino-math
  [n r]
  (/ (factorial n)
     (* (factorial r) (factorial (- n r)))))
;; (bino-math 4 2) ; => 6
```

#### ;; 코드8.1 재귀 호출을 이용한 이항 계수의 계산. 209p
```clojure
;; 코드8.1 재귀 호출을 이용한 이항 계수의 계산. 209p

(defn bino
  "nCr을 반환한다"
  [n r]
  (if (or (zero? r) (= n r))
    1
    (+ (bino (- n 1) (- r 1)) (bino (- n 1) r))))

;; (bino 4 2) ; => 6
```

#### ;; 코드8.2 메모이제이션을 이용한 이항 계수의 계산. 211p
```clojure
;; 코드8.2 메모이제이션을 이용한 이항 계수의 계산. 211p
(defn string-nCr
  [n r]
  (str n "C" r))

(def cache (atom {}))

(defn bino2
  [n r]
  (if (or (zero? r) (= n r))
    1
    ;; n, r로부터 string "nCr"을 얻어오고,
    (let [cache-key (string-nCr n r)]

      (if-let [cached-nCr (find @cache cache-key)]
        ;; cache["nCr"]이 있으면, cache["nCr"]을 반환하고,
        (val cached-nCr)

        ;; 아니면, nCr(n, r)을 계산해서, cache["nCr"] = nCr(n, r)을 넣고 반환한다.
        (let [nCr (+ (bino2 (- n 1) (- r 1)) (bino2 (- n 1) r))]
          (swap! cache assoc cache-key nCr)
          nCr)))))

;; (bino2 4 2) ; => 6
;; cache ; => #<Atom@67ae2ffe: {"4C2" 6, "3C2" 3, "3C1" 3, "2C1" 2}>

```

--------------------------------------------------------------------------------

### 메모이제이션을 적용할 수 있는 경우
* `memization`은 `referentail transparent`가 가능한 경우에 적용가능.
 - `memoization`: 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재사용하는 최적화 기법.
 - `cache`: 이미 계산한 값을 저장해 두는 메모리 장소.
 - `referentail transparent`: 함수의 반환 값이 입력 값만으로 결정되는것.

* 프로그래밍에서 주의점.
 - 전역변수.
 - 클래스 변수.
 - 입력객체(파일 등등)
 - 등등..

--------------------------------------------------------------------------------

### 메모이제이션 구현 패턴
- 딱히 별로 중요하지 않은듯.
 * 기저 사례 처리
 * cache의 초기값 설정
 * 배열일경우, ref이용.
 * memset을 이용 cache[]초기화

--------------------------------------------------------------------------------

#### clojure에서는??

clojure.core/memoize의 소스.

```clojure
(defn memoize
  "Returns a memoized version of a referentially transparent function. The
  memoized version of the function keeps a cache of the mapping from arguments
  to results and, when calls with the same arguments are repeated often, has
  higher performance at the expense of higher memory use."
  {:added "1.0"
   :static true}
  [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
```

atom dic에 args를 키로해서 캐슁하는것...

먼가 이상하다.

검색중 [projecteuler]를 근성으로 풀어가고 있는 [용자][blog:clojure-memoize]발견.

문제점을 확인할 수 있었음.

```clojure
;; ref: http://ypsilonbox.blogspot.kr/2011/06/clojure-memoize.html
(defn fib [n]
  (do
    (println "->"n)
    (if (<= n 1)
      n
      (+ (fib (dec n)) (fib (- n 2))))))

(def mem-fib (memoize fib))
(mem-fib 4)
(mem-fib 3)
(mem-fib 5)
```

```clojure
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; create memoised func

(defmacro defn-memo
  "Creates memoised function, and accessor of the memo which named -data,
   memo deletion function named -clear"
  [name arg-list & body]
  `(let [mem# (atom {})]

     (defn ~(symbol (str (str name) "-data")) []
       @mem#)

     (defn ~(symbol (str (str name) "-clear")) []
       (reset! mem# {}))

     (defn ~name ~arg-list
       (if-let [e# (find @mem# ~arg-list)]
          (val e#)
          (let [ret# ~@body]
              (swap! mem# assoc ~arg-list ret#)
              ret#)))))
;;

(defn-memo mem-fib [n]
  (do
     (println "-->" n)
     (if (<= n 1)
        n
        (+ (mem-fib (dec n)) (mem-fib (- n 2))))))

(mem-fib 4)
(mem-fib 3)
(mem-fib 5)
(mem-fib-data)
(mem-fib-clear)
(mem-fib-data)
```

물론 단순히 args에 의해 결정되는 memoize도 필요하나. clojure.core/memoize는 cache관리가 어렵다.

누가 해논건 없나? => [github:core.memoize]
cache 정책 및 조작할 수 있는 api제공.

--------------------------------------------------------------------------------

### 메모이제이션의 시간 복잡도 분석
* (존재하는 부분 문제의 수) x (한 부분 문제를 풀때 필요한 반복문의 수행 횟수)


```
bibo2를 보자면...

존재하는 부분 문제의 수. 최악의 경우는 다이아몬드를 이룰때임.

      1
     1 1
    1 2 1
   1 3 3 1
  1 4 6 4 1
 1 5 10 10 5 1
1 6 15 20 15 6 1

2C1 =>  4 - 중심이 (1 1)     - 2개
4C2 =>  9 - 중심이 (1 2 1)   - 3개
6C3 => 16 - 중심이 (1 3 3 1) - 4개


nCr의 n을 a라, 중심의 갯수를 n이라 하면
n = a/2 + 1


4C2를 예로들면
      1     - 1 * 2
     1 1    - 2 * 2
    1 2 1   - 3 * 1
     3 3 
      6

계산할 때 만날 수 있는 부분 문제의 수는
sigma(k = 1 ~ n) : (2 * k) - n - 1(이때 1은 자기자신)


2 * (n*(n+1)/2) - n = n^2

이제 n을 a/2+1로 치환하면

O(1/4a^2 + a + 1) = O(1/4a^2) = O(a^2).

캐쉬가 한번도 안된 최악의 경우이지, 됐다하면 수행시간은 더 짧아질것임.
```
--------------------------------------------------------------------------------

### 예제: 외발뛰기 (문제ID:JUMPGAME, 난이도: 하)

--------------------------------------------------------------------------------

## 8.02 문제: 와일드카드 (문제 ID:WILDCARD, 난이도: 중)

## 8.03 풀이: 와일드카드

--------------------------------------------------------------------------------

## 8.04 전통적 최적화 문제들

--------------------------------------------------------------------------------

## 8.05 문제: 합친LIS(문제 ID JLIS, 난이도: 하)
LIS가 뭐지?

## 8.06 풀이: 합친 LIS

--------------------------------------------------------------------------------

## 8.07 문제: 원주율 외우기 (문제ID:PI, 난이도: 하)

## 8.08 풀이: 원주율 외우기

--------------------------------------------------------------------------------

==== 여기까지 1차 목표. =======

## 8.09 문제: Quatization (문제 ID: QUANTIZE, 난이도: 중)
## 8.10 풀이: Quatization
## 8.11 경우의 수와 확률
## 8.12 문제: 비대칭 타일링 (문제 ID: ASYMTILING, 난이도: 하)
## 8.13 풀이: 비대칭 타일링
## 8.14 문제: 폴리오미노 (문제 ID: POLY, 난이도: 중)
## 8.15 풀이: 폴리오미노
## 8.16 문제: 두니발 박사의 탈옥 (문제 ID: NUMB3RS, 난이도: 중)
## 8.17 풀이: 두니발 박사의 탈옥

==== 여기까지 2차 목표. =======

# 느낀점
 - `동적 계획법`이란 단어가 생소해서 선택했는데... 과연..
 - 
 - 


[blog:dynamic programming?]: http://siriuseven.egloos.com/563101
[wiki:Dynamic_programming]: http://en.wikipedia.org/wiki/Dynamic_programming
[wiki:Overapping_subproblem]: http://en.wikipedia.org/wiki/Overlapping_subproblem
[wiki:Optimal_substructure]: http://en.wikipedia.org/wiki/Optimal_substructure
[projecteuler]: http://projecteuler.net/
[blog:clojure-memoize]: http://translate.google.com/translate?sl=ja&tl=ko&js=n&u=http://ypsilonbox.blogspot.kr/2011/06/clojure-memoize.html
[github:core.memoize]: https://github.com/clojure/core.memoize
[ppt:동적 프로그래밍-강원대학교]: cs.kangwon.ac.kr/~ysmoon/courses/2007_1/alg/06.ppt